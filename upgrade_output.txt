File "C:\Users\Dell\OneDrive\Documents\proverif\proverifbin2.05\5G_EAP-TLS_protocol_test3.pv", line 78, characters 7-14:
Warning: identifier Ksession rebound.
File "C:\Users\Dell\OneDrive\Documents\proverif\proverifbin2.05\5G_EAP-TLS_protocol_test3.pv", line 129, characters 9-14:
Warning: identifier HSAUSF rebound.
Process 0 (that is, the initial process):
{1}new skUE: skey;
{2}new skAUSF: skey;
{3}new skUDM: skey;
{4}new sskAUSF: sskey;
{5}new sskUE: sskey;
{6}new SEAFN: bitstring;
{7}let pkUE: pkey = pk(skUE) in
{8}out(c1, pkUE);
{9}out(c2, pkUE);
{10}out(c3, pkUE);
{11}let pkAUSF: pkey = pk(skAUSF) in
{12}out(c1, pkAUSF);
{13}out(c2, pkAUSF);
{14}out(c3, pkAUSF);
{15}let pkUDM: pkey = pk(skUDM) in
{16}out(c1, pkUDM);
{17}out(c2, pkUDM);
{18}out(c3, pkUDM);
{19}let spkAUSF: spkey = spk(sskAUSF) in
{20}out(c1, spkAUSF);
{21}out(c2, spkAUSF);
{22}out(c3, spkAUSF);
{23}let spkUE: spkey = spk(sskUE) in
{24}out(c1, spkUE);
{25}out(c2, spkUE);
{26}out(c3, spkUE);
(
    {27}!
    {28}let sskUE_1: sskey = sskUE in
    {29}let skUE_1: skey = skUE in
    {30}new Rue: bitstring;
    {31}out(c1, aenc((SUPI,Rue),pkUDM));
    {32}in(c1, y: bitstring);
    {33}let (Startx: bitstring,RueCheck: bitstring) = adec(y,skUE_1) in
    {34}let =Rue = RueCheck in
    {35}new Rue1: bitstring;
    {36}out(c1, aenc((Rue1,Startx),pkAUSF));
    {37}in(c1, (x: bitstring,CertAUSFx: bitstring));
    {38}let (Rausfx: bitstring,Rue1Check: bitstring) = adec(x,skUE_1) in
    {39}let =Rue1 = Rue1Check in
    {40}let =CertAUSF = CertAUSFx in
    {41}new Rprekey: bitstring;
    {42}let a: bitstring = h(Rue1,Rausfx,Rprekey) in
    {43}let Ksession_1: key = a in
    {44}let HSUE: bitstring = (Startx,Rue1,Rausfx,CertAUSFx) in
    {45}event acceptsUE(Rue1);
    {46}event sendPrek(Rprekey);
    {47}out(c1, (aenc((Rprekey,Rue),pkAUSF),CertUE,sign(HSUE,sskUE_1),senc(HSUE,Ksession_1)));
    {48}in(c1, HSAUSFx: bitstring);
    {49}let (HSUECheck: bitstring,SUPICheck: bitstring) = sdec(HSAUSFx,Ksession_1) in
    {50}let =HSUE = HSUECheck in
    {51}let =SUPI = SUPICheck in
    {52}new EAPM: bitstring;
    {53}out(c1, EAPM);
    {54}in(c1, SUCMx: bitstring);
    {55}event termUE(Rausfx)
) | (
    {56}!
    {57}let SEAFN_1: bitstring = SEAFN in
    {58}in(c1, x1: bitstring);
    {59}out(c2, (x1,SEAFN_1));
    {60}in(c2, x2: bitstring);
    {61}out(c1, x2);
    {62}in(c1, x3: bitstring);
    {63}out(c2, x3);
    {64}in(c2, (x4: bitstring,x5: bitstring));
    {65}out(c1, (x4,x5));
    {66}in(c1, (x6: bitstring,x7: bitstring,x8: bitstring,x9: bitstring));
    {67}out(c2, (x6,x7,x8,x9));
    {68}in(c2, x10: bitstring);
    {69}out(c1, x10);
    {70}in(c1, EAPMx: bitstring);
    {71}out(c2, EAPMx);
    {72}in(c2, SUCMx_1: bitstring);
    {73}out(c1, SUCMx_1)
) | (
    {74}!
    {75}let skAUSF_1: skey = skAUSF in
    {76}let sskAUSF_1: sskey = sskAUSF in
    {77}let SEAFN_2: bitstring = SEAFN in
    {78}in(c2, (SUPIx: bitstring,SEAFNx: bitstring));
    {79}if (SEAFNx = SEAFN_2) then
    {80}out(c3, (SUPIx,SEAFNx));
    {81}in(c3, Startx_1: bitstring);
    {82}out(c2, aenc((Startx_1,SUPIx),pkUE));
    {83}in(c2, v: bitstring);
    {84}let (Rue1x: bitstring,StartCheck: bitstring) = adec(v,skAUSF_1) in
    {85}let =Startx_1 = StartCheck in
    {86}new Rausf: bitstring;
    {87}out(c2, (aenc((Rausf,Rue1x),pkUE),CertAUSF));
    {88}in(c2, (y_1: bitstring,CertUEx: bitstring,t: bitstring,z: bitstring));
    {89}let =CertUE = CertUEx in
    {90}let (prekeyx: bitstring,RueCheck_1: bitstring) = adec(y_1,skAUSF_1) in
    {91}let b: bitstring = h(Rue1x,Rausf,prekeyx) in
    {92}let Ksessionx: key = b in
    {93}new HSAUSF: bitstring;
    {94}let HSAUSF_1: bitstring = (Startx_1,Rue1x,Rausf,CertAUSF) in
    {95}let HSAUSFCheck: bitstring = sdec(z,Ksessionx) in
    {96}let =HSAUSF_1 = HSAUSFCheck in
    {97}let SignatureCheck: bitstring = checksign(t,spkUE) in
    {98}let =HSAUSF_1 = SignatureCheck in
    {99}event acceptPrek(prekeyx);
    {100}event acceptsAUSF(Rue1x);
    {101}out(c2, senc((HSAUSF_1,SUPIx),Ksessionx));
    {102}in(c2, EAPMx_1: bitstring);
    {103}new SUCM: bitstring;
    {104}out(c2, SUCM);
    {105}event termAUSF(Rue1x)
) | (
    {106}!
    {107}let skUDM_1: skey = skUDM in
    {108}in(c3, (x_1: bitstring,SEAFNx_1: bitstring));
    {109}let (SUPIx_1: bitstring,Ruex: bitstring) = adec(x_1,skUDM_1) in
    {110}if (SUPIx_1 = SUPI) then
    {111}new start: bitstring;
    {112}out(c3, start)
)

--  Process 1 (that is, process 0, with let moved downwards):
{1}new skUE: skey;
{2}new skAUSF: skey;
{3}new skUDM: skey;
{4}new sskAUSF: sskey;
{5}new sskUE: sskey;
{6}new SEAFN: bitstring;
{7}let pkUE: pkey = pk(skUE) in
{8}out(c1, pkUE);
{9}out(c2, pkUE);
{10}out(c3, pkUE);
{11}let pkAUSF: pkey = pk(skAUSF) in
{12}out(c1, pkAUSF);
{13}out(c2, pkAUSF);
{14}out(c3, pkAUSF);
{15}let pkUDM: pkey = pk(skUDM) in
{16}out(c1, pkUDM);
{17}out(c2, pkUDM);
{18}out(c3, pkUDM);
{19}let spkAUSF: spkey = spk(sskAUSF) in
{20}out(c1, spkAUSF);
{21}out(c2, spkAUSF);
{22}out(c3, spkAUSF);
{23}let spkUE: spkey = spk(sskUE) in
{24}out(c1, spkUE);
{25}out(c2, spkUE);
{26}out(c3, spkUE);
(
    {27}!
    {30}new Rue: bitstring;
    {31}out(c1, aenc((SUPI,Rue),pkUDM));
    {32}in(c1, y: bitstring);
    {29}let skUE_1: skey = skUE in
    {33}let (Startx: bitstring,RueCheck: bitstring) = adec(y,skUE_1) in
    {34}let =Rue = RueCheck in
    {35}new Rue1: bitstring;
    {36}out(c1, aenc((Rue1,Startx),pkAUSF));
    {37}in(c1, (x: bitstring,CertAUSFx: bitstring));
    {38}let (Rausfx: bitstring,Rue1Check: bitstring) = adec(x,skUE_1) in
    {39}let =Rue1 = Rue1Check in
    {40}let =CertAUSF = CertAUSFx in
    {41}new Rprekey: bitstring;
    {45}event acceptsUE(Rue1);
    {46}event sendPrek(Rprekey);
    {44}let HSUE: bitstring = (Startx,Rue1,Rausfx,CertAUSFx) in
    {42}let a: bitstring = h(Rue1,Rausfx,Rprekey) in
    {43}let Ksession_1: key = a in
    {28}let sskUE_1: sskey = sskUE in
    {47}out(c1, (aenc((Rprekey,Rue),pkAUSF),CertUE,sign(HSUE,sskUE_1),senc(HSUE,Ksession_1)));
    {48}in(c1, HSAUSFx: bitstring);
    {49}let (HSUECheck: bitstring,SUPICheck: bitstring) = sdec(HSAUSFx,Ksession_1) in
    {50}let =HSUE = HSUECheck in
    {51}let =SUPI = SUPICheck in
    {52}new EAPM: bitstring;
    {53}out(c1, EAPM);
    {54}in(c1, SUCMx: bitstring);
    {55}event termUE(Rausfx)
) | (
    {56}!
    {58}in(c1, x1: bitstring);
    {57}let SEAFN_1: bitstring = SEAFN in
    {59}out(c2, (x1,SEAFN_1));
    {60}in(c2, x2: bitstring);
    {61}out(c1, x2);
    {62}in(c1, x3: bitstring);
    {63}out(c2, x3);
    {64}in(c2, (x4: bitstring,x5: bitstring));
    {65}out(c1, (x4,x5));
    {66}in(c1, (x6: bitstring,x7: bitstring,x8: bitstring,x9: bitstring));
    {67}out(c2, (x6,x7,x8,x9));
    {68}in(c2, x10: bitstring);
    {69}out(c1, x10);
    {70}in(c1, EAPMx: bitstring);
    {71}out(c2, EAPMx);
    {72}in(c2, SUCMx_1: bitstring);
    {73}out(c1, SUCMx_1)
) | (
    {74}!
    {78}in(c2, (SUPIx: bitstring,SEAFNx: bitstring));
    {77}let SEAFN_2: bitstring = SEAFN in
    {79}if (SEAFNx = SEAFN_2) then
    {80}out(c3, (SUPIx,SEAFNx));
    {81}in(c3, Startx_1: bitstring);
    {82}out(c2, aenc((Startx_1,SUPIx),pkUE));
    {83}in(c2, v: bitstring);
    {75}let skAUSF_1: skey = skAUSF in
    {84}let (Rue1x: bitstring,StartCheck: bitstring) = adec(v,skAUSF_1) in
    {85}let =Startx_1 = StartCheck in
    {86}new Rausf: bitstring;
    {87}out(c2, (aenc((Rausf,Rue1x),pkUE),CertAUSF));
    {88}in(c2, (y_1: bitstring,CertUEx: bitstring,t: bitstring,z: bitstring));
    {89}let =CertUE = CertUEx in
    {90}let (prekeyx: bitstring,RueCheck_1: bitstring) = adec(y_1,skAUSF_1) in
    {93}new HSAUSF: bitstring;
    {91}let b: bitstring = h(Rue1x,Rausf,prekeyx) in
    {92}let Ksessionx: key = b in
    {95}let HSAUSFCheck: bitstring = sdec(z,Ksessionx) in
    {94}let HSAUSF_1: bitstring = (Startx_1,Rue1x,Rausf,CertAUSF) in
    {96}let =HSAUSF_1 = HSAUSFCheck in
    {97}let SignatureCheck: bitstring = checksign(t,spkUE) in
    {98}let =HSAUSF_1 = SignatureCheck in
    {99}event acceptPrek(prekeyx);
    {100}event acceptsAUSF(Rue1x);
    {101}out(c2, senc((HSAUSF_1,SUPIx),Ksessionx));
    {102}in(c2, EAPMx_1: bitstring);
    {103}new SUCM: bitstring;
    {104}out(c2, SUCM);
    {105}event termAUSF(Rue1x)
) | (
    {106}!
    {108}in(c3, (x_1: bitstring,SEAFNx_1: bitstring));
    {107}let skUDM_1: skey = skUDM in
    {109}let (SUPIx_1: bitstring,Ruex: bitstring) = adec(x_1,skUDM_1) in
    {110}if (SUPIx_1 = SUPI) then
    {111}new start: bitstring;
    {112}out(c3, start)
)

-- Query not attacker(prekey[]) in process 1.
Translating the process into Horn clauses...
Termination warning: Selecting an hypothesis matching the conclusion.
In case of non-termination, try a noselect declaration implying the following one:
   noselect x2_1:bitstring; mess(c2[],*x2_1).
Completing...
Starting query not attacker(prekey[])
RESULT not attacker(prekey[]) is true.
-- Query not attacker(Ksession[]) in process 1.
Translating the process into Horn clauses...
Termination warning: Selecting an hypothesis matching the conclusion.
In case of non-termination, try a noselect declaration implying the following one:
   noselect x2_1:bitstring; mess(c2[],*x2_1).
Completing...
Starting query not attacker(Ksession[])
RESULT not attacker(Ksession[]) is true.
-- Query not attacker(SUPI[]) in process 1.
Translating the process into Horn clauses...
Termination warning: Selecting an hypothesis matching the conclusion.
In case of non-termination, try a noselect declaration implying the following one:
   noselect x2_1:bitstring; mess(c2[],*x2_1).
Completing...
Starting query not attacker(SUPI[])
RESULT not attacker(SUPI[]) is true.
-- Query inj-event(acceptPrek(x_2)) ==> inj-event(sendPrek(x_2)) in process 1.
Translating the process into Horn clauses...
Termination warning: Selecting an hypothesis matching the conclusion.
In case of non-termination, try a noselect declaration implying the following one:
   noselect x2_1:bitstring; mess(c2[],*x2_1).
Completing...
Starting query inj-event(acceptPrek(x_2)) ==> inj-event(sendPrek(x_2))
RESULT inj-event(acceptPrek(x_2)) ==> inj-event(sendPrek(x_2)) is true.
-- Query inj-event(termAUSF(x_2)) ==> inj-event(acceptsUE(x_2)) in process 1.
Translating the process into Horn clauses...
Termination warning: Selecting an hypothesis matching the conclusion.
In case of non-termination, try a noselect declaration implying the following one:
   noselect x2_1:bitstring; mess(c2[],*x2_1).
Completing...
Starting query inj-event(termAUSF(x_2)) ==> inj-event(acceptsUE(x_2))
RESULT inj-event(termAUSF(x_2)) ==> inj-event(acceptsUE(x_2)) is true.
-- Query inj-event(termUE(x_2)) ==> inj-event(acceptsAUSF(x_2)) in process 1.
Translating the process into Horn clauses...
Termination warning: Selecting an hypothesis matching the conclusion.
In case of non-termination, try a noselect declaration implying the following one:
   noselect x2_1:bitstring; mess(c2[],*x2_1).
Completing...
Starting query inj-event(termUE(x_2)) ==> inj-event(acceptsAUSF(x_2))
RESULT inj-event(termUE(x_2)) ==> inj-event(acceptsAUSF(x_2)) is true.

--------------------------------------------------------------
Verification summary:

Query not attacker(prekey[]) is true.

Query not attacker(Ksession[]) is true.

Query not attacker(SUPI[]) is true.

Query inj-event(acceptPrek(x_2)) ==> inj-event(sendPrek(x_2)) is true.

Query inj-event(termAUSF(x_2)) ==> inj-event(acceptsUE(x_2)) is true.

Query inj-event(termUE(x_2)) ==> inj-event(acceptsAUSF(x_2)) is true.

--------------------------------------------------------------

